package com.util;
import java.sql.*;
import java.util.PropertyResourceBundle;
import java.util.Enumeration;

public class DataBase {
	
private static String url;						//数据库连接字串
private static String userName;				//数据库用户名称
private static String driver;					//数据库驱动名称
private static String pwd;						//数据库用户登陆密码
private final static String fileName="database";	//属性文件名称
	//ThreadLocal 当前线程局部变量
@SuppressWarnings("rawtypes")
private static ThreadLocal connection=new ThreadLocal();

	static{
		readConfig();
	}

	//	getConn方法用于获取数据库连接
	/**
	 * synchronized 控制对类成员变量的访问：每个类实例对应一把锁，
	 * 每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，
	 * 否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才
	 * 将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制
	 * 确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数
	 * 中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），
	 * 从而有效避免了类成员变量的访问冲突
	 */ 
	@SuppressWarnings("unchecked")
	public synchronized static Connection getConn()throws SQLException{
		Connection con=(Connection) connection.get();
		if (con!=null && !con.isClosed()){
			return con;
		}
			try{
				@SuppressWarnings("unused")
				Class providerClass=Class.forName(driver);
				con=DriverManager.getConnection(url,userName,pwd);
				//setAutoCommit
				//将此连接的自动提交模式设置为给定状态。如果连接处于自动提交模式下，则将执行其所有 SQL 语句，并将这些语句作为单独的事务提交。
				//否则，其 SQL 语句将成组地进入通过调用 commit 方法或 rollback 方法终止的事务中。默认情况下，新的连接处于自动提交模式下。 
				con.setAutoCommit(false);
				connection.set(con);
				return con;
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
			return null;
	}

	//读取配置文件信息
	@SuppressWarnings("unchecked")
	private static void readConfig(){
		//PropertyResourceBundle使用属性文件中的静态字符串集合来管理语言环境资源。
		PropertyResourceBundle prb=(PropertyResourceBundle) PropertyResourceBundle
			.getBundle(fileName);
		//枚举Enumeration
		Enumeration enu=prb.getKeys();
		while (enu.hasMoreElements()){
			String propertyName=enu.nextElement().toString();
		//读取配置文件中的静态字符串并且赋值给类成员变量
			if (propertyName.equals("database.driver"))
				driver=prb.getString("database.driver");
			if (propertyName.equals("database.url"))
				url=prb.getString("database.url");
			if (propertyName.equals("database.username"))
				userName=prb.getString("database.username");
			if (propertyName.equals("database.password"))
				pwd=prb.getString("database.password");
		}
	}
		
	//	commit 使自从上一次提交/回滚以来进行的所有更改成为持久更改，并释放此 Connection 对象当前保存的所有数据库锁定。
	//  此方法应该只在已禁用自动提交模式时使用。 
	public static void commit(){
		Connection con=(Connection) connection.get();
		try{
			con.commit();
		}catch(SQLException e){
			e.printStackTrace();
		}
	}
	//回滚事务
	public static void rollback(){
		Connection con=(Connection) connection.get();
		try{
			con.rollback() ;
		}catch (SQLException e){
			e.printStackTrace();
		}
	}
	//释放数据库连接
	public synchronized static void releaseConnection(Connection connection){
		try{
			if (connection!= null && !connection.isClosed())
				connection.close();
		}catch(SQLException e){
			e.printStackTrace();
		}
		connection=null;
	}
	
	public static void main(String[] args){
		try{
			DataBase.getConn();
		}catch(Exception e){
			e.printStackTrace();
		}
	}
}
